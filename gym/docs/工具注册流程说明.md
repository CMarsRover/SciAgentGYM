# 工具注册流程说明

## 概述

本模块实现了从数据集到环境工具箱的完整工具注册流程，支持从 `usage_tool_protocol` 自动加载和注册工具。

## 核心流程

```
数据集 (usage_tool_protocol)
    ↓
load_tools_for_case() - 提取工具协议，验证格式，动态导入函数
    ↓
register_tools_to_env() - 包装成 GenericFunctionTool，注册到环境
    ↓
MinimalSciEnv + OpenAI tools schema
```

## 主要函数

### 1. `load_tools_for_case(test_case: dict)`

从测试案例中加载工具协议和函数。

**输入：**
- `test_case`: 包含 `usage_tool_protocol` 字段的测试案例字典

**输出：**
- `tools`: 验证后的工具协议列表
- `function_map`: `{function_name: callable}` 映射

**功能：**
- 提取 `usage_tool_protocol` 中的工具定义
- 验证工具协议格式（通过 `validate_function_tool`）
- 从 `function_path` 动态导入 Python 函数（通过 `dynamic_import_tool_functions`）
- 处理类格式工具（嵌套的 `tools` 列表）
- 可选去重（根据元数据决定）

### 2. `register_tools_to_env(tool_protocols, function_map)`

将工具注册到环境中。

**输入：**
- `tool_protocols`: 工具协议列表
- `function_map`: 函数映射

**输出：**
- `env`: MinimalSciEnv 实例
- `tool_instances`: EnvironmentTool 实例列表
- `tools_schema`: OpenAI tools schema 列表
- `tool_registry`: `{tool_name: EnvironmentTool}` 映射

**功能：**
- 为每个工具创建 `GenericFunctionTool` 实例
- 将工具注册到 `MinimalSciEnv`
- 构建 OpenAI tools schema（供 LLM 调用）
- 构建工具注册表（供运行时查找）

### 3. `load_and_register_tools_for_case(test_case)`

一站式函数，完整流程。

**输入：**
- `test_case`: 测试案例字典

**输出：**
- 同 `register_tools_to_env`

## 使用示例

### 基本用法

```python
from gym.tool_loader import load_and_register_tools_for_case
import json

# 加载测试案例
with open('gym/dataset/refine_merged_questions_augmented.json', 'r') as f:
    cases = json.load(f)
    test_case = cases[0]  # 取第一个案例

# 加载并注册工具
env, tool_instances, tools_schema, tool_registry = load_and_register_tools_for_case(test_case)

# 查看注册的工具
print(f"已注册 {len(tool_instances)} 个工具:")
for tool in tool_instances:
    print(f"  - {tool.name}: {tool.description[:50]}...")

# 使用 OpenAI tools schema 调用 LLM
# tools_schema 可以直接传给 LLM 的 tools 参数
```

### 分步使用

```python
from gym.tool_loader import load_tools_for_case, register_tools_to_env

# 步骤1: 加载工具协议和函数
tool_protocols, function_map = load_tools_for_case(test_case)

# 步骤2: 注册到环境
env, tool_instances, tools_schema, tool_registry = register_tools_to_env(
    tool_protocols, 
    function_map
)
```

### 执行工具调用

```python
from gym.tool import ToolCall
from gym.tool_loader import run_tool_call

# 创建工具调用
tool_call = ToolCall(
    id="call-1",
    name="voigt_function",
    arguments={
        "x": [1, 2, 3, 4, 5],
        "amplitude": 100,
        "center": 3,
        "sigma": 0.5,
        "gamma": 0.3
    }
)

# 执行调用
result = run_tool_call(env, tool_call.name, tool_call.arguments, tool_call.id)
print(result)
```

## 数据结构

### 测试案例格式

```json
{
    "id": 49,
    "question": "...",
    "usage_tool_protocol": [
        {
            "type": "function",
            "function": {
                "name": "voigt_function",
                "description": "...",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "x": {"type": "array", "items": {"type": "number"}},
                        "amplitude": {"type": "number"}
                    },
                    "required": ["x", "amplitude"]
                }
            },
            "additionalProperties": {
                "function_path": "./tools/xps_spectroscopy_toolkit_0001.py"
            }
        }
    ]
}
```

### function_path 查找规则

函数会按以下顺序查找文件：

1. 项目根目录下的直接路径
2. `toolkits/` 目录下
3. `tools/` 目录下
4. `toolkits/{discipline}/` 目录下（physics, chemistry, materials_science 等）

## 关键特性

1. **自动路径解析**：支持多种路径格式，自动查找工具文件
2. **动态导入**：运行时动态导入函数，无需预注册
3. **格式验证**：自动验证工具协议格式
4. **错误处理**：友好的错误提示和日志记录
5. **去重支持**：根据元数据自动去重工具
6. **类工具支持**：支持类格式的工具（嵌套 `tools` 列表）

## 注意事项

1. 确保工具文件路径正确，函数名与协议中的 `name` 一致
2. 工具函数应该是纯函数，不依赖全局状态
3. 函数参数应该与协议中的 `parameters` 定义匹配
4. 大型工具集建议使用去重功能，避免重复加载

