# Filename: organic_reaction_simulator.py

from ast import pattern
import numpy as np
import matplotlib.pyplot as plt
from rdkit import Chem
from rdkit.Chem import AllChem, Draw
try:
    from py_smiles import chemistry_text_2_SMILES
except ModuleNotFoundError:
    import os, sys
    sys.path.append(os.path.dirname(os.path.dirname(__file__)))
    from py_smiles import chemistry_text_2_SMILES
import os
from scipy.optimize import minimize
import re
import subprocess
import tempfile
import shutil

def _mol_from_smiles_safe(smiles):
    """
    在函数内部做一次宽松标准化后再解析SMILES。
    - 处理常见负离子写法（如 CCO- -> CC[O-]）
    - 去除空格
    失败则返回None
    """
    if smiles is None:
        return None
    s = str(smiles).strip()
    # 仅在未被方括号包裹时，将裸露的阴离子后缀规范化为带括号形式
    s = re.sub(r"(?<!\[)O-(?!\])", "[O-]", s)
    s = re.sub(r"(?<!\[)N-(?!\])", "[N-]", s)
    s = re.sub(r"(?<!\[)S-(?!\])", "[S-]", s)
    try:
        return Chem.MolFromSmiles(s)
    except Exception:
        return None

def _has_substructure(mol, smarts):
    patt = Chem.MolFromSmarts(smarts)
    return False if patt is None else mol.HasSubstructMatch(patt)

def _substrate_degree_class(mol):
    """粗略按卤代烷碳中心取代程度分类：primary/secondary/tertiary/unknown"""
    lg = Chem.MolFromSmarts("[CX4;!$(*=*)]-[Br,Cl,I]")
    if lg is None:
        return 'unknown'
    matches = mol.GetSubstructMatches(lg)
    if not matches:
        return 'unknown'
    c_idx = matches[0][0]
    atom = mol.GetAtomWithIdx(c_idx)
    cnt = sum(1 for nbr in atom.GetNeighbors() if nbr.GetAtomicNum() == 6)
    if cnt <= 1:
        return 'primary'
    if cnt == 2:
        return 'secondary'
    if cnt >= 3:
        return 'tertiary'
    return 'unknown'

def _has_leaving_group(mol):
    return _has_substructure(mol, "[Br,Cl,I]")

def _mol_to_xyz(mol):
    mol = Chem.AddHs(mol)
    if AllChem.EmbedMolecule(mol, randomSeed=42) != 0:
        AllChem.EmbedMolecule(mol, AllChem.ETKDG())
    try:
        ff = AllChem.MMFFGetMoleculeForceField(mol, AllChem.MMFFGetMoleculeProperties(mol))
    except Exception:
        ff = AllChem.UFFGetMoleculeForceField(mol)
    if ff:
        ff.Minimize()
    conf = mol.GetConformer()
    lines = [str(mol.GetNumAtoms()), "generated by RDKit"]
    for atom in mol.GetAtoms():
        pos = conf.GetAtomPosition(atom.GetIdx())
        lines.append(f"{atom.GetSymbol()} {pos.x:.8f} {pos.y:.8f} {pos.z:.8f}")
    return "\n".join(lines)

def _xtb_single_point_energy_kjmol(mol):
    tmpdir = tempfile.mkdtemp(prefix="xtb_run_")
    try:
        xyz = _mol_to_xyz(mol)
        xyz_path = os.path.join(tmpdir, "coord.xyz")
        with open(xyz_path, "w", encoding="utf-8") as f:
            f.write(xyz + "\n")
        # run xTB GFN2 single-point
        proc = subprocess.run(["xtb", "coord.xyz", "--gfn", "2", "--sp"], cwd=tmpdir, capture_output=True, text=True, timeout=120)
        out = proc.stdout + "\n" + proc.stderr
        # Parse total energy in Eh
        # Typical line:  total energy      -40.123456 Eh
        energy_eh = None
        for line in out.splitlines():
            if "total energy" in line and "Eh" in line:
                try:
                    tokens = line.strip().split()
                    # last-but-one token is value, last is Eh
                    for i, t in enumerate(tokens):
                        if t == "energy" and i+1 < len(tokens):
                            pass
                    # simpler parse: take the last numeric before 'Eh'
                    val = None
                    for i in range(len(tokens)-1):
                        if tokens[i+1] == "Eh":
                            val = float(tokens[i])
                    if val is not None:
                        energy_eh = val
                        break
                except Exception:
                    continue
        if energy_eh is None:
            raise RuntimeError("Failed to parse xTB energy")
        # convert Eh to kJ/mol (1 Eh = 2625.49962 kJ/mol)
        return energy_eh * 2625.49962
    finally:
        shutil.rmtree(tmpdir, ignore_errors=True)

def _mmff_energy_kjmol(mol):
    mol = Chem.AddHs(mol)
    if AllChem.EmbedMolecule(mol, randomSeed=42) != 0:
        AllChem.EmbedMolecule(mol, AllChem.ETKDG())
    try:
        ff = AllChem.MMFFGetMoleculeForceField(mol, AllChem.MMFFGetMoleculeProperties(mol))
    except Exception:
        ff = AllChem.UFFGetMoleculeForceField(mol)
    if ff is None:
        raise ValueError("无法为分子创建力场")
    ff.Minimize()
    return ff.CalcEnergy() * 4.184


def _pick_organic_product(pset):
    """从产物集合中挑选有机主产物（排除卤阴离子等）。"""
    for p in pset:
        if p is None:
            continue
        smi = Chem.MolToSmiles(p)
        if any(anion in smi for anion in ("[Br-]", "[Cl-]", "[I-]")) or smi.strip() == "":
            continue
        try:
            m = Chem.MolFromSmiles(smi)
            if m is not None:
                return Chem.MolToSmiles(m, canonical=True)
        except Exception:
            continue
    return None

def _run_reaction_sn2_oxygen(nuc_mol, sub_mol):
    # SN2: 醇盐O-进攻卤代烷碳（显式单键）
    # 放宽底物碳的限制，并支持多种卤素离去基团
    # 反应： [$([O-]:1),$([O;H0]:1)].[C:2]-[Br,Cl,I:3] >> [O:1]-[C:2].[Br-:3,Cl-:3,I-:3]
    SN2_OXYGEN_SMARTS_LIST = [
    "[$([O-]:1),$([O;H0]:1)].[C:2]-[Br:3]>>[O:1]-[C:2].[Br-:3]",
    "[$([O-]:1),$([O;H0]:1)].[C:2]-[Cl:3]>>[O:1]-[C:2].[Cl-:3]",
    "[$([O-]:1),$([O;H0]:1)].[C:2]-[I:3]>>[O:1]-[C:2].[I-:3]",
]
    rxn = AllChem.ReactionFromSmarts('[O-:1].[C;X4:2][Br:3]>>[O:1][C:2].[Br-:3]')
    prods = rxn.RunReactants((nuc_mol, sub_mol))
    print(prods)
    if not prods:
        return None
    for pset in prods:
        smi = _pick_organic_product(pset)
        if smi:
            return smi
    return None

def _run_reaction_sn2_carbanion(nuc_mol, sub_mol):
    # SN2: 碳负离子进攻卤代烷（显式单键）
    # 放宽底物碳的限制，并支持多种卤素离去基团
    # 反应： [C-:1].[C:2]-[Br,Cl,I:3] >> [C:1]-[C:2].[*:3-]
    rxn = AllChem.ReactionFromSmarts("[C-:1].[C:2]-[Br,Cl,I:3]>>[C:1]-[C:2].[*:3-]")
    prods = rxn.RunReactants((nuc_mol, sub_mol))
    if not prods:
        return None
    for pset in prods:
        smi = _pick_organic_product(pset)
        if smi:
            return smi
    return None

def _run_cation_hydration(nuc_mol, sub_mol):
    # 碳正离子与水加成（简化）： [O;H2:1].[C+:2] >> [O:1]-[C:2]
    rxn = AllChem.ReactionFromSmarts("[O;H2:1].[C+:2]>>[O:1]-[C:2]")
    prods = rxn.RunReactants((nuc_mol, sub_mol))
    if not prods:
        return None
    for pset in prods:
        smi = _pick_organic_product(pset)
        if smi:
            return smi
    return None

def generate_product_via_smarts(nuc_smiles, sub_smiles):
    # 接收字符串SMILES，转换为Mol
    nuc = _mol_from_smiles_safe(nuc_smiles)
    sub = _mol_from_smiles_safe(sub_smiles)
    if nuc is None or sub is None:
        return None
    # SN2: oxygen anion or neutral oxygen (H0)
    if ( _has_substructure(nuc, "[O-]") or _has_substructure(nuc, "[O;H0]") ) and _has_leaving_group(sub):
        smi = _run_reaction_sn2_oxygen(nuc, sub)
        if smi:
            return smi
    # SN2: carbanion
    if _has_substructure(nuc, "[C-]") and _has_leaving_group(sub):
        smi = _run_reaction_sn2_carbanion(nuc, sub)
        if smi:
            return smi
    # Cation hydration (water as nucleophile)
    if _has_substructure(sub, "[C+]") and _has_substructure(nuc, "[O]"):
        smi = _run_cation_hydration(nuc, sub)
        if smi:
            return smi
    return None

def simulate_nucleophilic_substitution(nucleophile, substrate, solvent="neutral", temperature=298.15):
    """
    模拟有机化学中的亲核取代反应，预测产物和反应能量。
    
    该函数基于亲核试剂和底物的结构，模拟SN1或SN2反应机理，预测主要产物和副产物。
    
    Parameters:
    -----------
    nucleophile : str
        亲核试剂的SMILES表示，例如 "CH3O-" 表示甲氧基负离子
    substrate : str
        底物的SMILES表示，例如 "CH3Br" 表示溴甲烷
    solvent : str, optional
        溶剂类型，可选值为 "polar", "nonpolar", "neutral"，默认为 "neutral"
    temperature : float, optional
        反应温度，单位为K，默认为298.15K (25°C)
        
    Returns:
    --------
    dict
        包含以下键的字典:
        - 'product_smiles': 主要产物的SMILES表示
        - 'reaction_type': 反应类型 ('SN1' 或 'SN2')
        - 'energy_barrier': 估计的反应能垒 (kJ/mol)
        - 'product_mol': RDKit分子对象，表示主要产物
    """
    # 这里是简化的反应模拟逻辑
    # 实际应用中需要更复杂的量子化学计算或机器学习模型
    
    # 先将文本/化学式规范化为SMILES，再进行解析
    # 仅当直接SMILES解析失败时，调用文本转换器

    nucleophile_smiles = chemistry_text_2_SMILES(nucleophile)  
    substrate_smiles = chemistry_text_2_SMILES(substrate)


   
    # 简化的反应类型判断逻辑
    # 实际应用中需要分析底物结构、离去基团等因素
    # 判断离去基团与底物位阻，给出机理倾向
    # has_lg = _has_leaving_group(sub_mol)
    # degree = _substrate_degree_class(sub_mol)
    # solv_sn2 = {"polar": 0.8, "nonpolar": 1.2, "neutral": 1.0}
    # solv_sn1 = {"polar": 0.6, "nonpolar": 1.5, "neutral": 1.0}
    # base_sn2 = 55.0
    # base_sn1 = 70.0
    # if has_lg and degree in ("primary", "secondary"):
    #     reaction_type = "SN2"
    #     energy_barrier = base_sn2 * solv_sn2.get(solvent, 1.0) * (298.15/temperature)
    # else:
    #     reaction_type = "SN1"
    #     energy_barrier = base_sn1 * solv_sn1.get(solvent, 1.0) * (298.15/temperature)
    # # 用SMARTS构建产物；失败则抛出清晰错误，避免返回非SMILES占位符
    product_smiles = generate_product_via_smarts(nucleophile_smiles, substrate_smiles)
    if not product_smiles:
        raise ValueError("未能基于输入生成有效的产物SMILES，请检查亲核试剂/底物是否包含有效的离去基和负离子形式（如 CC[O-], CBr）")
    
    product_mol = Chem.MolFromSmiles(product_smiles)
    
    return {
        'product_smiles': product_smiles,
        # 'reaction_type': reaction_type,
        # 'energy_barrier': energy_barrier,
        'product_mol': product_mol
    }

def predict_hydrolysis_product(substrate, pH=7.0, temperature=298.15):
    """
    预测有机化合物在水解条件下的产物。
    
    基于底物结构和反应条件，模拟水解反应并预测主要产物。
    
    Parameters:
    -----------
    substrate : str
        底物的SMILES表示，例如 "CH3C(OCH3)2+" 表示缩醛正离子
    pH : float, optional
        反应溶液的pH值，默认为7.0（中性）
    temperature : float, optional
        反应温度，单位为K，默认为298.15K (25°C)
        
    Returns:
    --------
    dict
        包含以下键的字典:
        - 'product_smiles': 主要产物的SMILES表示
        - 'reaction_mechanism': 反应机理描述
        - 'half_life': 估计的反应半衰期 (s)
        - 'product_mol': RDKit分子对象，表示主要产物
    """
    # 简化的水解反应模拟
    # 实际应用中需要考虑更多结构因素和反应条件
    
    sub_mol = chemistry_text_2_SMILES(substrate)
    if sub_mol is None:
        raise ValueError("无法解析SMILES字符串，请检查输入")
    # 使用SMARTS子结构匹配替代字符串包含
    if _has_substructure(sub_mol, "C(OC)(OC)"):
        product_smiles = "CC=O"
        mechanism = "缩醛水解为醛和醇"
    elif _has_substructure(sub_mol, "C(=O)O[C,H]"):
        product_smiles = "CC(=O)O"
        mechanism = "酯水解为羧酸和醇"
    elif _has_substructure(sub_mol, "C#N"):
        product_smiles = "CC(=O)O"
        mechanism = "腈水解为羧酸"
    else:
        product_smiles = "CCO"
        mechanism = "未识别特定水解机理"
    
    # 简化的反应速率计算
    # 实际应用中需要基于实验数据或量子化学计算
    base_half_life = 3600.0  # 基础半衰期，单位s
    
    # pH影响因子
    if pH < 3.0:
        ph_factor = 0.1  # 酸催化加速
    elif pH > 10.0:
        ph_factor = 0.2  # 碱催化加速
    else:
        ph_factor = 1.0  # 中性条件
    
    # 温度影响 (简化的阿伦尼乌斯方程)
    temp_factor = np.exp(5000 * (1/298.15 - 1/temperature))
    
    half_life = base_half_life * ph_factor * temp_factor
    
    product_mol = Chem.MolFromSmiles(product_smiles)
    
    return {
        'product_smiles': product_smiles,
        'reaction_mechanism': mechanism,
        'half_life': half_life,
        'product_mol': product_mol
    }

def calculate_reaction_energy(reactants, products, method="semi-empirical"):
    """
    计算有机反应的能量变化。
    
    使用量子化学方法计算反应物和产物之间的能量差异，评估反应的热力学可行性。
    
    Parameters:
    -----------
    reactants : list of str
        反应物的SMILES表示列表
    products : list of str
        产物的SMILES表示列表
    method : str, optional
        计算方法，可选值为 "semi-empirical", "DFT", "force-field"，默认为 "semi-empirical"
        
    Returns:
    --------
    dict
        包含以下键的字典:
        - 'delta_H': 反应焓变 (kJ/mol)
        - 'delta_G': 反应吉布斯自由能变化 (kJ/mol)
        - 'is_spontaneous': 反应是否自发进行的布尔值
    """
    # 实际应用中需要调用量子化学计算软件或使用机器学习模型
    # 这里提供一个简化的模拟实现
    
    # 检查输入分子的有效性
    for smiles in reactants + products:
        if Chem.MolFromSmiles(smiles) is None:
            raise ValueError(f"无法解析SMILES: {smiles}")
    
    # 简化的能量计算
    # 在实际应用中，应使用RDKit的MMFF或UFF力场，或调用外部量子化学软件
    
    # 模拟不同计算方法的精度和计算成本
    method_params = {
        "semi-empirical": {"accuracy": 0.8, "noise": 5.0},
        "DFT": {"accuracy": 0.95, "noise": 2.0},
        "force-field": {"accuracy": 0.6, "noise": 10.0}
    }
    
    params = method_params.get(method, method_params["semi-empirical"])
    
    # 简化的能量计算 (实际应用中应基于分子结构计算)
    # 这里使用随机值模拟计算结果
    np.random.seed(hash(''.join(reactants + products)) % 2**32)
    
    # 模拟反应焓变 (通常在 -200 到 200 kJ/mol 范围内)
    base_delta_h = -50.0  # 假设这是一个放热反应
    delta_h = base_delta_h * params["accuracy"] + np.random.normal(0, params["noise"])
    
    # 模拟熵变贡献 (通常在 -50 到 50 kJ/mol 范围内)
    entropy_contribution = -20.0  # 假设熵减少
    
    # 计算吉布斯自由能变化 ΔG = ΔH - TΔS
    delta_g = delta_h - entropy_contribution
    
    return {
        'delta_H': delta_h,
        'delta_G': delta_g,
        'is_spontaneous': delta_g < 0
    }

def visualize_reaction_pathway(reaction_steps, energies, title="反应能量图", out_path="./images/reaction_pathway.png"):
    """
    可视化有机反应的能量路径。
    
    创建反应坐标与能量关系图，展示反应的能量变化过程。
    
    Parameters:
    -----------
    reaction_steps : list of str
        反应步骤的描述列表
    energies : list of float
        对应每个反应步骤的能量值 (kJ/mol)
    title : str, optional
        图表标题，默认为 "反应能量图"
        
    Returns:
    --------
    matplotlib.figure.Figure
        生成的图表对象
    """
    if len(reaction_steps) != len(energies):
        raise ValueError("反应步骤和能量列表长度必须相同")
    
    # 设置中文字体支持
    plt.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS', 'DejaVu Sans']
    plt.rcParams['axes.unicode_minus'] = False
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # 绘制能量曲线
    x = np.arange(len(reaction_steps))
    ax.plot(x, energies, 'o-', linewidth=2, markersize=8)
    
    # 添加数据标签
    for i, energy in enumerate(energies):
        ax.text(i, energy + 5, f"{energy:.1f} kJ/mol", ha='center')
    
    # 设置坐标轴和标签
    ax.set_xticks(x)
    ax.set_xticklabels(reaction_steps, rotation=45, ha='right')
    ax.set_ylabel('能量 (kJ/mol)')
    ax.set_title(title)
    
    # 添加网格线
    ax.grid(True, linestyle='--', alpha=0.7)
    
    # 计算和标记能垒
    barriers = []
    for i in range(1, len(energies)):
        barrier = energies[i] - energies[i-1]
        if barrier > 0:
            barriers.append((i-1, i, barrier))
    
    for start, end, barrier in barriers:
        mid_x = (start + end) / 2
        max_y = max(energies[start], energies[end]) + barrier/2
        ax.annotate(f"能垒: {barrier:.1f} kJ/mol",
                   xy=(mid_x, max_y),
                   xytext=(mid_x, max_y + 15),
                   arrowprops=dict(arrowstyle='->'),
                   ha='center')
    
    plt.tight_layout()
    
    # 确保图像目录存在
    os.makedirs(os.path.dirname(out_path) or ".", exist_ok=True)
    # 保存图像
    plt.savefig(out_path, dpi=300, bbox_inches='tight')
    return fig

def optimize_molecular_geometry(smiles, force_field="MMFF94", max_iterations=1000):
    """
    优化分子几何构型，寻找能量最低构象。
    
    使用分子力场或量子化学方法优化分子的三维结构。
    
    Parameters:
    -----------
    smiles : str
        分子的SMILES表示
    force_field : str, optional
        使用的力场类型，可选值为 "MMFF94", "UFF"，默认为 "MMFF94"
    max_iterations : int, optional
        优化的最大迭代次数，默认为1000
        
    Returns:
    --------
    dict
        包含以下键的字典:
        - 'optimized_mol': 优化后的RDKit分子对象
        - 'energy': 优化后的分子能量 (kJ/mol)
        - 'converged': 优化是否收敛的布尔值
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        raise ValueError(f"无法解析SMILES: {smiles}")
    
    # 添加氢原子
    mol = Chem.AddHs(mol)
    
    # 生成初始3D构象
    AllChem.EmbedMolecule(mol, randomSeed=42)
    
    # 选择力场
    if force_field == "MMFF94":
        ff = AllChem.MMFFGetMoleculeForceField(mol, AllChem.MMFFGetMoleculeProperties(mol))
    elif force_field == "UFF":
        ff = AllChem.UFFGetMoleculeForceField(mol)
    else:
        raise ValueError(f"不支持的力场类型: {force_field}")
    
    if ff is None:
        raise ValueError(f"无法为分子创建力场: {smiles}")
    
    # 执行能量最小化
    converged = ff.Minimize(maxIts=max_iterations)
    
    # 获取最终能量 (kcal/mol 转换为 kJ/mol)
    energy = ff.CalcEnergy() * 4.184
    
    return {
        'optimized_mol': mol,
        'energy': energy,
        'converged': converged == 0  # 0表示成功收敛
    }

def predict_organic_reaction_products(reactants, reaction_type, conditions=None):
    """
    预测有机反应的产物。
    
    基于反应物和反应类型，预测可能的产物及其分布。
    
    Parameters:
    -----------
    reactants : list of str
        反应物的SMILES表示列表
    reaction_type : str
        反应类型，如 "SN2", "E2", "aldol", "Diels-Alder" 等
    conditions : dict, optional
        反应条件，包含温度、溶剂、催化剂等信息
        
    Returns:
    --------
    dict
        包含以下键的字典:
        - 'products': 产物SMILES列表
        - 'yields': 对应产物的预计产率列表 (百分比)
        - 'major_product': 主要产物的SMILES
    """
    if conditions is None:
        conditions = {"temperature": 298.15, "solvent": "neutral", "catalyst": None}
    
    # 检查反应物
    for smiles in reactants:
        if Chem.MolFromSmiles(smiles) is None:
            raise ValueError(f"无法解析SMILES: {smiles}")
    
    # 简化的反应预测逻辑
    # 实际应用中应使用反应规则数据库或机器学习模型
    
    # 示例：SN2反应预测
    if reaction_type.upper() == "SN2":
        if len(reactants) >= 2:
            nucleophile = reactants[0]
            substrate = reactants[1]
            
            # 简化的SN2产物预测
            if "CH3CH2O-" in nucleophile and "CH3Br" in substrate:
                products = ["CH3CH2OCH3"]
                yields = [95.0]
            elif "CN-" in nucleophile and "CH3CH2Cl" in substrate:
                products = ["CH3CH2CN"]
                yields = [90.0]
            else:
                # 默认产物
                products = ["Product_SN2"]
                yields = [80.0]
    
    # 示例：水解反应预测
    elif reaction_type.upper() == "HYDROLYSIS":
        if len(reactants) >= 1:
            substrate = reactants[0]
            
            # 简化的水解产物预测
            if "C(=O)OC" in substrate:  # 酯水解
                products = ["C(=O)O", "COH"]
                yields = [85.0, 85.0]
            elif "C#N" in substrate:  # 腈水解
                products = ["C(=O)O", "NH3"]
                yields = [75.0, 75.0]
            else:
                # 默认产物
                products = ["Product_Hydrolysis"]
                yields = [70.0]
    
    # 默认情况
    else:
        products = ["Unknown_Product"]
        yields = [50.0]
    
    # 确定主要产物
    major_product_index = yields.index(max(yields))
    major_product = products[major_product_index]
    
    return {
        'products': products,
        'yields': yields,
        'major_product': major_product
    }

def main():
    """
    主函数：演示如何使用工具函数求解有机化学反应问题
    """
    print("===== 有机化学反应模拟工具演示 =====")
    
    # 示例1：亲核取代反应
    print("\n1. 亲核取代反应模拟")
    print("反应: CH3CH2O- + CH3-Br → ?")
    
    result = simulate_nucleophilic_substitution("CC[O-]", "CBr", solvent="polar")
    
    print(f"预测产物: {result['product_smiles']}")
    print(f"反应类型: {result['reaction_type']}")
    print(f"能量垒: {result['energy_barrier']:.2f} kJ/mol")
    
    # 示例2：水解反应
    print("\n2. 水解反应模拟")
    print("反应: CH3-C(OCH3)2+ + H2O → ?")
    
    hydrolysis_result = predict_hydrolysis_product("CC(OC)OC", pH=3.0)
    
    print(f"预测产物: {hydrolysis_result['product_smiles']}")
    print(f"反应机理: {hydrolysis_result['reaction_mechanism']}")
    print(f"半衰期: {hydrolysis_result['half_life']:.2f} s")
    
    # 示例3：反应能量计算
    print("\n3. 反应能量计算")
    print("反应: CH3CH2CH2-CH2-Br + H2C- → ?")
    
    reactants = ["CCCCC", "C"]  # 简化的SMILES
    products = ["CCCC=C"]  # 简化的SMILES
    
    energy_result = calculate_reaction_energy(reactants, products, method="DFT")
    
    print(f"反应焓变 ΔH: {energy_result['delta_H']:.2f} kJ/mol")
    print(f"反应自由能变化 ΔG: {energy_result['delta_G']:.2f} kJ/mol")
    print(f"反应是否自发: {'是' if energy_result['is_spontaneous'] else '否'}")
    
    # 示例4：反应路径可视化
    print("\n4. 反应路径可视化")
    
    steps = ["反应物", "过渡态1", "中间体", "过渡态2", "产物"]
    energies = [0.0, 45.0, 15.0, 60.0, -25.0]
    
    fig = visualize_reaction_pathway(steps, energies, title="SN2反应能量图", out_path="./images/reaction_pathway.png")
    print("反应路径图已保存至 ./images/reaction_pathway.png")
    
    # 示例5：分子几何优化
    print("\n5. 分子几何优化")
    
    try:
        opt_result = optimize_molecular_geometry("CCO", force_field="MMFF94")
        print(f"优化后能量: {opt_result['energy']:.2f} kJ/mol")
        print(f"优化是否收敛: {'是' if opt_result['converged'] else '否'}")
    except Exception as e:
        print(f"优化过程出错: {str(e)}")
    
    # 示例6：有机反应产物预测
    print("\n6. 有机反应产物预测")
    
    reaction_result = predict_organic_reaction_products(
        ["CC[O-]", "CBr"], 
        "SN2", 
        {"temperature": 323.15, "solvent": "DMSO"}
    )
    
    print(f"预测产物: {', '.join(reaction_result['products'])}")
    print(f"预计产率: {', '.join([f'{y:.1f}%' for y in reaction_result['yields']])}")
    print(f"主要产物: {reaction_result['major_product']}")
    
    print("\n===== 演示完成 =====")

if __name__ == "__main__":
    main()